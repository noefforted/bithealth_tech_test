I organized the project using a Layered Architecture to keep the code clean and organized. I separated the application into different folders: api for handling requests, services for the RAG logic, and repositories for interacting with the Qdrant database. By using Dependency Injection in FastAPI, each part of the system is independent. This makes it easier to test the code and swap out different components without breaking the entire application.

A key trade-off I made was using the recreate_collection method during the application startup. The advantage is that it ensures the database schema always matches the settings in the .env file, which is very helpful during the development and testing phase. However, the downside is that it sacrifices data persistence, meaning all stored vectors are deleted and reset every time the app restarts. I decided this was acceptable for this technical test to ensure a consistent and predictable testing environment.

My version improves maintainability by using API Versioning (/api/v1) and a Centralized Configuration system. By putting all settings in a .env file and using a dedicated configuration class, the app can be moved to different environments easily. Additionally, the separation of the /status endpoint into a monitoring module allows for system health checks without interfering with the main business logic. This structure makes it simple for other developers to add new features or update the database in the future.